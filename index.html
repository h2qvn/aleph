<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ— é™æ›¼å¾·å‹ƒç½— | æ—¶é—´åˆ†å½¢è‰ºæœ¯</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a12;
            color: #e0e0ff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #header {
            background: rgba(10, 10, 25, 0.9);
            padding: 15px;
            border-bottom: 1px solid #2a2a4a;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        .title {
            font-size: 1.5em;
            font-weight: bold;
            color: #7aa2f7;
            text-shadow: 0 0 10px rgba(122, 162, 247, 0.5);
        }
        .time-info {
            display: flex;
            gap: 20px;
            font-size: 0.9em;
        }
        .time-item {
            background: rgba(20, 20, 40, 0.8);
            padding: 8px 15px;
            border-radius: 6px;
            border: 1px solid #3a3a6a;
        }
        .time-value {
            color: #f7768e;
            font-weight: bold;
        }
        #controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        label {
            color: #9ece6a;
            font-size: 0.9em;
        }
        input, select {
            background: rgba(20, 20, 40, 0.8);
            border: 1px solid #3a3a6a;
            color: #e0e0ff;
            padding: 6px 12px;
            border-radius: 4px;
            font-family: monospace;
        }
        button {
            background: #7aa2f7;
            color: #1a1a2a;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }
        button:hover {
            background: #9ece6a;
        }
        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 25, 0.9);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid #3a3a6a;
            z-index: 100;
        }
        #loading p {
            margin: 10px 0;
            color: #7aa2f7;
        }
        #fps {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(10, 10, 25, 0.8);
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 0.9em;
            border: 1px solid #3a3a6a;
        }
        #zoom-level {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(10, 10, 25, 0.8);
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 0.9em;
            border: 1px solid #3a3a6a;
        }
        .error {
            color: #f7768e;
            margin-top: 10px;
        }
        .success {
            color: #9ece6a;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="header">
        <div class="title">âˆ æ›¼å¾·å‹ƒç½—æ—¶é—´åˆ†å½¢ âˆ</div>
        <div class="time-info">
            <div class="time-item">
                çºªå…ƒæ—¶é—´: <span id="epochTime" class="time-value">åŒæ­¥ä¸­...</span>
            </div>
            <div class="time-item">
                æµé€æ—¶é—´: <span id="elapsedTime" class="time-value">0ms</span>
            </div>
        </div>
        <div id="controls">
            <div class="control-group">
                <label for="zoomSpeed">æ”¾å¤§é€Ÿåº¦:</label>
                <input type="range" id="zoomSpeed" min="0.1" max="10" step="0.1" value="1">
                <span id="zoomSpeedValue">1.0x</span>
            </div>
            <div class="control-group">
                <label for="colorScheme">é…è‰²æ–¹æ¡ˆ:</label>
                <select id="colorScheme">
                    <option value="cosmic">å®‡å®™æ·±ç©º</option>
                    <option value="fire">ç‚½çƒ­ç«ç„°</option>
                    <option value="ice">æåœ°å¯’å†°</option>
                    <option value="rainbow">å½©è™¹å…‰è°±</option>
                </select>
            </div>
            <button id="syncTime">é‡æ–°åŒæ­¥æ—¶é—´</button>
        </div>
    </div>
    
    <div id="canvas-container">
        <canvas id="fractalCanvas"></canvas>
        <div id="loading">
            <p>ğŸŒŒ æ­£åœ¨åˆå§‹åŒ–æ— é™åˆ†å½¢å®‡å®™...</p>
            <p>æ­£åœ¨åŒæ­¥å®‡å®™æ—¶é—´...</p>
            <p id="syncStatus" class="success">å°è¯•ä»ä¸–ç•Œæ—¶é—´APIè·å–...</p>
        </div>
        <div id="fps">FPS: <span>--</span></div>
        <div id="zoom-level">ç¼©æ”¾çº§åˆ«: <span>1e0</span></div>
    </div>

    <script>
        // ==================== é…ç½® ====================
        const CONFIG = {
            // çºªå…ƒèµ·å§‹æ—¶é—´ï¼š2025-12-10 07:00:00 UTC+8
            EPOCH_START: new Date('2025-11-10T07:00:00+08:00').getTime(),
            
            // æ›¼å¾·å‹ƒç½—å‚æ•°
            MANDELBROT: {
                MAX_ITERATIONS: 500,
                ESCAPE_RADIUS: 4.0,
                ZOOM_EXPONENT: 0.00005, // æ—¶é—´åˆ°ç¼©æ”¾çš„æŒ‡æ•°ç³»æ•°
                CENTER_X: -0.7436438870371587, // æœ‰è¶£çš„æ›¼å¾·å‹ƒç½—ä½ç½®
                CENTER_Y: 0.13182590420531198,
                INITIAL_ZOOM: 1.0
            },
            
            // æ—¶é—´åŒæ­¥è®¾ç½®
            TIME_API_URL: 'https://worldtimeapi.org/api/timezone/Asia/Shanghai',
            MAX_RETRIES: 5,
            RETRY_DELAY: 2000
        };

        // ==================== å…¨å±€çŠ¶æ€ ====================
        const state = {
            // WebGL
            gl: null,
            program: null,
            canvas: null,
            
            // æ—¶é—´ç³»ç»Ÿ
            epochTime: null,      // çºªå…ƒæ—¶é—´æˆ³
            currentTime: null,    // å½“å‰æ—¶é—´æˆ³
            elapsedTime: 0,       // ä»çºªå…ƒå¼€å§‹æµé€çš„æ—¶é—´(ms)
            isTimeSynced: false,
            timeSyncRetries: 0,
            
            // æ¸²æŸ“çŠ¶æ€
            isRunning: false,
            lastFrameTime: 0,
            frameCount: 0,
            fps: 0,
            lastFpsUpdate: 0,
            
            // æ›¼å¾·å‹ƒç½—å‚æ•°
            zoom: CONFIG.MANDELBROT.INITIAL_ZOOM,
            centerX: CONFIG.MANDELBROT.CENTER_X,
            centerY: CONFIG.MANDELBROT.CENTER_Y,
            
            // ç”¨æˆ·æ§åˆ¶
            zoomSpeed: 1.0,
            colorScheme: 'cosmic'
        };

        // ==================== WebGL ç€è‰²å™¨ ====================
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_texCoord;
            
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = a_position * 0.5 + 0.5;
            }
        `;

        const fragmentShaderSource = `
            precision highp float;
            
            varying vec2 v_texCoord;
            
            // Uniforms
            uniform float u_time;
            uniform vec2 u_center;
            uniform float u_zoom;
            uniform int u_maxIterations;
            uniform float u_escapeRadius;
            uniform int u_colorScheme;
            
            // é¢œè‰²æ–¹æ¡ˆå‡½æ•°
            vec3 cosmicColor(float t) {
                float r = 0.5 + 0.5 * cos(6.28318 * (t + 0.0));
                float g = 0.5 + 0.5 * cos(6.28318 * (t + 0.33));
                float b = 0.5 + 0.5 * cos(6.28318 * (t + 0.67));
                return vec3(r, g, b);
            }
            
            vec3 fireColor(float t) {
                float r = 1.0 - exp(-t * 3.0);
                float g = 0.8 - exp(-t * 4.0);
                float b = 0.2 - exp(-t * 5.0);
                return vec3(r, g, b);
            }
            
            vec3 iceColor(float t) {
                float r = 0.2 + 0.8 * (1.0 - exp(-t * 2.0));
                float g = 0.5 + 0.5 * (1.0 - exp(-t * 3.0));
                float b = 1.0 - exp(-t * 1.0);
                return vec3(r, g, b);
            }
            
            vec3 rainbowColor(float t) {
                float hue = t * 6.0;
                float r = abs(hue - 3.0) - 1.0;
                float g = 2.0 - abs(hue - 2.0);
                float b = 2.0 - abs(hue - 4.0);
                return clamp(vec3(r, g, b), 0.0, 1.0);
            }
            
            void main() {
                // å°†å±å¹•åæ ‡æ˜ å°„åˆ°å¤å¹³é¢
                vec2 c = u_center + (v_texCoord - 0.5) * 4.0 / u_zoom;
                
                // æ›¼å¾·å‹ƒç½—è¿­ä»£
                vec2 z = vec2(0.0, 0.0);
                int iterations = 0;
                
                for (int i = 0; i < 1000; i++) {
                    if (i >= u_maxIterations) break;
                    
                    // z = z^2 + c
                    float x2 = z.x * z.x;
                    float y2 = z.y * z.y;
                    float xy = z.x * z.y;
                    
                    z.x = x2 - y2 + c.x;
                    z.y = 2.0 * xy + c.y;
                    
                    // æ£€æŸ¥æ˜¯å¦é€ƒé€¸
                    if (x2 + y2 > u_escapeRadius * u_escapeRadius) {
                        iterations = i;
                        break;
                    }
                    iterations = i;
                }
                
                // è®¡ç®—å½’ä¸€åŒ–çš„è¿­ä»£æ¬¡æ•°
                float t = float(iterations) / float(u_maxIterations);
                
                // æ ¹æ®é¢œè‰²æ–¹æ¡ˆé€‰æ‹©é¢œè‰²
                vec3 color;
                if (u_colorScheme == 0) {
                    color = cosmicColor(t);
                } else if (u_colorScheme == 1) {
                    color = fireColor(t);
                } else if (u_colorScheme == 2) {
                    color = iceColor(t);
                } else {
                    color = rainbowColor(t);
                }
                
                // å¹³æ»‘ç€è‰²
                if (iterations < u_maxIterations) {
                    // å¯¹æ•°å¹³æ»‘
                    float log_zn = log(z.x * z.x + z.y * z.y) / 2.0;
                    float nu = log(log_zn / log(2.0)) / log(2.0);
                    t = (float(iterations) + 1.0 - nu) / float(u_maxIterations);
                    
                    // é‡æ–°è®¡ç®—å¹³æ»‘åçš„é¢œè‰²
                    if (u_colorScheme == 0) {
                        color = cosmicColor(t);
                    } else if (u_colorScheme == 1) {
                        color = fireColor(t);
                    } else if (u_colorScheme == 2) {
                        color = iceColor(t);
                    } else {
                        color = rainbowColor(t);
                    }
                } else {
                    // å†…éƒ¨ç‚¹è®¾ä¸ºé»‘è‰²
                    color = vec3(0.0);
                }
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // ==================== åˆå§‹åŒ– ====================
        async function init() {
            console.log('ğŸŒ€ åˆå§‹åŒ–æ— é™æ›¼å¾·å‹ƒç½—ç³»ç»Ÿ...');
            
            // è·å–Canvaså’ŒWebGLä¸Šä¸‹æ–‡
            state.canvas = document.getElementById('fractalCanvas');
            state.gl = state.canvas.getContext('webgl') || state.canvas.getContext('experimental-webgl');
            
            if (!state.gl) {
                showError('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒWebGL');
                return;
            }
            
            // è®¾ç½®Canvaså°ºå¯¸
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // ç¼–è¯‘ç€è‰²å™¨ç¨‹åº
            if (!initShaders()) {
                showError('ç€è‰²å™¨ç¼–è¯‘å¤±è´¥');
                return;
            }
            
            // åˆå§‹åŒ–å‡ ä½•ä½“
            initGeometry();
            
            // åˆå§‹åŒ–æ—¶é—´ç³»ç»Ÿ
            await initTimeSystem();
            
            // è®¾ç½®ç”¨æˆ·æ§åˆ¶
            setupControls();
            
            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            state.isRunning = true;
            requestAnimationFrame(renderLoop);
            
            console.log('âœ… ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
        }

        // ==================== WebGL åˆå§‹åŒ– ====================
        function initShaders() {
            try {
                // åˆ›å»ºç€è‰²å™¨ç¨‹åº
                const vertexShader = createShader(state.gl, state.gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = createShader(state.gl, state.gl.FRAGMENT_SHADER, fragmentShaderSource);
                
                state.program = createProgram(state.gl, vertexShader, fragmentShader);
                
                if (!state.program) {
                    return false;
                }
                
                // ä½¿ç”¨ç¨‹åº
                state.gl.useProgram(state.program);
                return true;
            } catch (error) {
                console.error('ç€è‰²å™¨é”™è¯¯:', error);
                return false;
            }
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('ç€è‰²å™¨ç¼–è¯‘é”™è¯¯:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('ç¨‹åºé“¾æ¥é”™è¯¯:', gl.getProgramInfoLog(program));
                return null;
            }
            
            return program;
        }

        function initGeometry() {
            // åˆ›å»ºå…¨å±å››è¾¹å½¢
            const positions = [
                -1.0, -1.0,
                 1.0, -1.0,
                -1.0,  1.0,
                 1.0,  1.0
            ];
            
            const positionBuffer = state.gl.createBuffer();
            state.gl.bindBuffer(state.gl.ARRAY_BUFFER, positionBuffer);
            state.gl.bufferData(state.gl.ARRAY_BUFFER, new Float32Array(positions), state.gl.STATIC_DRAW);
            
            // è®¾ç½®é¡¶ç‚¹å±æ€§
            const positionLocation = state.gl.getAttribLocation(state.program, 'a_position');
            state.gl.enableVertexAttribArray(positionLocation);
            state.gl.vertexAttribPointer(positionLocation, 2, state.gl.FLOAT, false, 0, 0);
        }

        // ==================== æ—¶é—´ç³»ç»Ÿ ====================
        async function initTimeSystem() {
            updateStatus('æ­£åœ¨è·å–ä¸–ç•Œæ—¶é—´...');
            
            try {
                const timeData = await fetchWorldTimeWithRetry();
                
                if (timeData) {
                    // è§£æAPIå“åº”
                    const currentTime = new Date(timeData.utc_datetime).getTime();
                    state.currentTime = currentTime;
                    state.epochTime = CONFIG.EPOCH_START;
                    state.elapsedTime = currentTime - state.epochTime;
                    state.isTimeSynced = true;
                    
                    updateTimeDisplays();
                    updateStatus(`âœ… æ—¶é—´åŒæ­¥æˆåŠŸ: ${new Date(currentTime).toLocaleString()}`, 'success');
                    document.getElementById('loading').style.display = 'none';
                    
                    console.log('æ—¶é—´åŒæ­¥å®Œæˆ:', {
                        å½“å‰æ—¶é—´: new Date(state.currentTime),
                        çºªå…ƒæ—¶é—´: new Date(state.epochTime),
                        æµé€æ—¶é—´: state.elapsedTime + 'ms'
                    });
                } else {
                    throw new Error('æ— æ³•è·å–æ—¶é—´æ•°æ®');
                }
            } catch (error) {
                console.warn('æ—¶é—´åŒæ­¥å¤±è´¥:', error);
                fallbackToLocalTime();
            }
        }

        async function fetchWorldTimeWithRetry() {
            state.timeSyncRetries = 0;
            
            while (state.timeSyncRetries < CONFIG.MAX_RETRIES) {
                try {
                    updateStatus(`å°è¯• ${state.timeSyncRetries + 1}/${CONFIG.MAX_RETRIES}...`);
                    
                    const response = await fetch(CONFIG.TIME_API_URL, {
                        signal: AbortSignal.timeout(5000)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const data = await response.json();
                    console.log('æ—¶é—´APIå“åº”:', data);
                    return data;
                } catch (error) {
                    state.timeSyncRetries++;
                    console.warn(`å°è¯• ${state.timeSyncRetries} å¤±è´¥:`, error);
                    
                    if (state.timeSyncRetries < CONFIG.MAX_RETRIES) {
                        updateStatus(`ç­‰å¾… ${CONFIG.RETRY_DELAY/1000}ç§’åé‡è¯•...`);
                        await new Promise(resolve => setTimeout(resolve, CONFIG.RETRY_DELAY));
                    }
                }
            }
            
            return null;
        }

        function fallbackToLocalTime() {
            console.log('åˆ‡æ¢åˆ°æœ¬åœ°æ—¶é—´æ¨¡å¼');
            state.currentTime = Date.now();
            state.epochTime = CONFIG.EPOCH_START;
            state.elapsedTime = state.currentTime - state.epochTime;
            state.isTimeSynced = false;
            
            updateTimeDisplays();
            updateStatus('âš ï¸ ä½¿ç”¨æœ¬åœ°ç³»ç»Ÿæ—¶é—´ï¼ˆå¯èƒ½ä¸å®Œå…¨åŒæ­¥ï¼‰', 'error');
            document.getElementById('loading').style.display = 'none';
        }

        function updateTimeDisplays() {
            // çºªå…ƒæ—¶é—´æ˜¾ç¤º
            const epochElement = document.getElementById('epochTime');
            if (epochElement) {
                const date = new Date(state.epochTime);
                epochElement.textContent = date.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });
            }
            
            // æµé€æ—¶é—´æ˜¾ç¤º
            const elapsedElement = document.getElementById('elapsedTime');
            if (elapsedElement) {
                const seconds = Math.floor(state.elapsedTime / 1000);
                const minutes = Math.floor(seconds / 60);
                const hours = Math.floor(minutes / 60);
                const days = Math.floor(hours / 24);
                
                if (days > 0) {
                    elapsedElement.textContent = `${days}d ${hours % 24}h ${minutes % 60}m`;
                } else if (hours > 0) {
                    elapsedElement.textContent = `${hours}h ${minutes % 60}m ${seconds % 60}s`;
                } else if (minutes > 0) {
                    elapsedElement.textContent = `${minutes}m ${seconds % 60}s`;
                } else {
                    elapsedElement.textContent = `${seconds}s`;
                }
            }
        }

        function updateStatus(message, type = 'normal') {
            const statusElement = document.getElementById('syncStatus');
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.className = type === 'success' ? 'success' : 
                                        type === 'error' ? 'error' : 'normal';
            }
        }

        // ==================== æ¸²æŸ“ç³»ç»Ÿ ====================
        function resizeCanvas() {
            const displayWidth = state.canvas.clientWidth;
            const displayHeight = state.canvas.clientHeight;
            
            if (state.canvas.width !== displayWidth || state.canvas.height !== displayHeight) {
                state.canvas.width = displayWidth;
                state.canvas.height = displayHeight;
                state.gl.viewport(0, 0, displayWidth, displayHeight);
            }
        }

        function updateZoomFromTime() {
            if (!state.isTimeSynced) {
                // ä½¿ç”¨æœ¬åœ°æ—¶é—´
                state.elapsedTime = Date.now() - state.epochTime;
            } else {
                // æ›´æ–°æµé€æ—¶é—´
                state.elapsedTime += 16; // å‡è®¾æ¯å¸§16msï¼Œå®é™…åº”è¯¥ç”¨ç²¾ç¡®æ—¶é—´å·®
            }
            
            // åŸºäºæ—¶é—´è®¡ç®—ç¼©æ”¾çº§åˆ«
            // ä½¿ç”¨æŒ‡æ•°å¢é•¿æ¥æ¨¡æ‹Ÿæ— é™æ”¾å¤§
            const timeInSeconds = state.elapsedTime / 1000;
            const zoomFactor = Math.exp(timeInSeconds * CONFIG.MANDELBROT.ZOOM_EXPONENT * state.zoomSpeed);
            state.zoom = CONFIG.MANDELBROT.INITIAL_ZOOM * zoomFactor;
            
            // æ›´æ–°ç¼©æ”¾æ˜¾ç¤º
            const zoomElement = document.querySelector('#zoom-level span');
            if (zoomElement) {
                zoomElement.textContent = `1e${Math.log10(state.zoom).toFixed(2)}`;
            }
        }

        function renderLoop(timestamp) {
            if (!state.isRunning) return;
            
            // è®¡ç®—FPS
            calculateFPS(timestamp);
            
            // æ›´æ–°åŸºäºæ—¶é—´çš„ç¼©æ”¾
            updateZoomFromTime();
            
            // æ›´æ–°Uniforms
            updateUniforms();
            
            // æ¸…é™¤ç”»å¸ƒ
            state.gl.clearColor(0.0, 0.0, 0.0, 1.0);
            state.gl.clear(state.gl.COLOR_BUFFER_BIT);
            
            // ç»˜åˆ¶
            state.gl.drawArrays(state.gl.TRIANGLE_STRIP, 0, 4);
            
            // è¯·æ±‚ä¸‹ä¸€å¸§
            requestAnimationFrame(renderLoop);
        }

        function updateUniforms() {
            const gl = state.gl;
            const program = state.program;
            
            // æ—¶é—´Uniform
            const timeLoc = gl.getUniformLocation(program, 'u_time');
            gl.uniform1f(timeLoc, state.elapsedTime / 1000.0);
            
            // ä¸­å¿ƒç‚¹Uniform
            const centerLoc = gl.getUniformLocation(program, 'u_center');
            gl.uniform2f(centerLoc, state.centerX, state.centerY);
            
            // ç¼©æ”¾Uniform
            const zoomLoc = gl.getUniformLocation(program, 'u_zoom');
            gl.uniform1f(zoomLoc, state.zoom);
            
            // æœ€å¤§è¿­ä»£æ¬¡æ•°
            const maxIterLoc = gl.getUniformLocation(program, 'u_maxIterations');
            gl.uniform1i(maxIterLoc, CONFIG.MANDELBROT.MAX_ITERATIONS);
            
            // é€ƒé€¸åŠå¾„
            const escapeLoc = gl.getUniformLocation(program, 'u_escapeRadius');
            gl.uniform1f(escapeLoc, CONFIG.MANDELBROT.ESCAPE_RADIUS);
            
            // é¢œè‰²æ–¹æ¡ˆ
            const colorSchemeMap = {
                'cosmic': 0,
                'fire': 1,
                'ice': 2,
                'rainbow': 3
            };
            const colorLoc = gl.getUniformLocation(program, 'u_colorScheme');
            gl.uniform1i(colorLoc, colorSchemeMap[state.colorScheme] || 0);
        }

        function calculateFPS(timestamp) {
            state.frameCount++;
            
            if (timestamp - state.lastFpsUpdate >= 1000) {
                state.fps = Math.round((state.frameCount * 1000) / (timestamp - state.lastFpsUpdate));
                state.frameCount = 0;
                state.lastFpsUpdate = timestamp;
                
                const fpsElement = document.querySelector('#fps span');
                if (fpsElement) {
                    fpsElement.textContent = state.fps;
                }
            }
        }

        // ==================== ç”¨æˆ·æ§åˆ¶ ====================
        function setupControls() {
            // æ”¾å¤§é€Ÿåº¦æ§åˆ¶
            const zoomSpeedInput = document.getElementById('zoomSpeed');
            const zoomSpeedValue = document.getElementById('zoomSpeedValue');
            
            zoomSpeedInput.addEventListener('input', function() {
                state.zoomSpeed = parseFloat(this.value);
                zoomSpeedValue.textContent = this.value + 'x';
            });
            
            // é¢œè‰²æ–¹æ¡ˆæ§åˆ¶
            const colorSchemeSelect = document.getElementById('colorScheme');
            colorSchemeSelect.addEventListener('change', function() {
                state.colorScheme = this.value;
            });
            
            // é‡æ–°åŒæ­¥æ—¶é—´æŒ‰é’®
            const syncButton = document.getElementById('syncTime');
            syncButton.addEventListener('click', async function() {
                document.getElementById('loading').style.display = 'block';
                updateStatus('æ­£åœ¨é‡æ–°åŒæ­¥æ—¶é—´...');
                await initTimeSystem();
            });
            
            // æ·»åŠ é”®ç›˜æ§åˆ¶
            document.addEventListener('keydown', handleKeyDown);
        }

        function handleKeyDown(event) {
            const moveStep = 0.1 / state.zoom;
            
            switch(event.key) {
                case 'ArrowUp':
                    state.centerY -= moveStep;
                    break;
                case 'ArrowDown':
                    state.centerY += moveStep;
                    break;
                case 'ArrowLeft':
                    state.centerX -= moveStep;
                    break;
                case 'ArrowRight':
                    state.centerX += moveStep;
                    break;
                case '+':
                case '=':
                    state.zoom *= 1.1;
                    break;
                case '-':
                case '_':
                    state.zoom /= 1.1;
                    break;
                case 'r':
                case 'R':
                    // é‡ç½®åˆ°åˆå§‹ä½ç½®
                    state.zoom = CONFIG.MANDELBROT.INITIAL_ZOOM;
                    state.centerX = CONFIG.MANDELBROT.CENTER_X;
                    state.centerY = CONFIG.MANDELBROT.CENTER_Y;
                    break;
            }
        }

        // ==================== å·¥å…·å‡½æ•° ====================
        function showError(message) {
            const loadingElement = document.getElementById('loading');
            if (loadingElement) {
                loadingElement.innerHTML = `<p class="error">âŒ ${message}</p>`;
            }
            console.error(message);
        }

        // ==================== å¯åŠ¨ ====================
        window.addEventListener('load', init);
        
        // å…¨å±€è®¿é—®
        window.FractalUniverse = {
            state,
            CONFIG,
            updateZoom: function(factor) {
                state.zoom *= factor;
            },
            moveCenter: function(dx, dy) {
                state.centerX += dx / state.zoom;
                state.centerY += dy / state.zoom;
            },
            setCenter: function(x, y) {
                state.centerX = x;
                state.centerY = y;
            }
        };
    </script>
</body>
</html>
